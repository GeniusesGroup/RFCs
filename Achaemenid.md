# Achaemenid - Server
The same when we write a letter, we don't think about how it will be delivered, Achaemenid used to think & design digital platform services locally by almost know related architecture like [SOA](https://en.wikipedia.org/wiki/Service-oriented_architecture) or [Microservices](https://en.wikipedia.org/wiki/Microservices) or [ServerLess](https://en.wikipedia.org/wiki/Serverless_computing) or NanoServices or [FaaS](https://en.wikipedia.org/wiki/Function_as_a_service) and let Achaemenid make runtime and do other things for your networking!! Result of Achaemenid is a runnable monolithic app that can do every thing for you such as authentication, authorization, routing, logging, ... in most efficient way! So Achaemenid [autogenerate](https://en.wikipedia.org/wiki/Automatic_programming#Source-code_generation) multi network handler for written services logic in specific template [like this](https://github.com/SabzCity/sabz.city). It will also make SDK in multi language for client usage.

## Supported Protocol
All information get from [IANA Resources](https://www.iana.org) like [IP Protocols](https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml), [Transport Protocols](https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml), ... But we don't support all of them now and some will never support due many problem in their architecture. Also we introduce new whole [network](./Giti.md) with lot of improvement in privacy and performance!

### GP - Giti Protocol
- Each Application lease 16bit range GP from OS router!
- Developers can choose to respect the whole packet structure or just the first 256 byte used for routing and change other structure as a requirement!

## Supported usage!
Achaemenid implementation must support at least three way as:
- API As a Service : Call needed service functions (APIs) from generator repository(folder).
- Version Controls : Part of CI/CD process like tests codes!
- CLI : Call needed API by user friendly commands!

## Rules
To write better business logic read these advices! A lot of way exist to handle service versions like  [Git Basics - Tagging](https://git-scm.com/book/en/v2/Git-Basics-Tagging), [Semantic Versioning](https://semver.org/) But we decide very innovative way explain below.

### Folders
Folders use just to group same logic platform services API. In `apis` folder of platform repository you must have `services` and inside it you can have as many as you need hierarchical folder tree to group services together!

### Services
You must follow this rules:
- Split each service (exported or public function) in one file to appreciate NanoService pattern! Never include more than one service in a file!
- Always make and complete ServiceDetail structure by server manifest rules!
- Achaemenid respect given ID by you to services indicate in ServiceDetail! But if it is empty(0) it will calculate it from hash of ServiceName! Due to hash collision, maybe force you to change ServiceName or indicate ID handy!
- Don't delete unneeded services files, just change related ServiceDetail like ExpireDate and status! and never ever use old service name for new service with different service structure!
---- SO DON'T REUSE OLD ID EVEN IF YOU DON'T NEED THEM EVER! ----
- You can change service structure before you indicate service is StableRelease in ServiceDetail! So don't changed it after it, Always make new service if you want change service structure by for example add `V1` to end of service name and dedicated file e.g. `register-new-person-v1.go`!
- As always use full detail name for service names(function). You can add random or specific ID to end of service name for reusability of that name.

### DataStore layer:
- It is better to have separate folder e.g. `datastore` for data layer architecture!
- Just call owner data store in each service and call other service function if need others data!

### Prohibited
- Autogenerated code should not be edited, since it may be automatically overwritten by the same process.

## Architecture details

## Security
- Everything only can run in security protocol like TLS. we force redirect http to https requests.

## Compress
To achieve better bandwidth we force to compress request and answer. e.g. gzip

## Management and analitics

## Logging

## Caching
We just cache HTTP GET method. we must work to cache other get method.

## AI
### Security
- [Quic Security Considerations](https://tools.ietf.org/html/draft-ietf-quic-transport-16#section-21)
- Track multi broken stream as kind of attack.
- Track for try to open multi guest connections. guest user can just one connection per IP.
- Track for stream fragmentation and reassembly attacks.
- Track for changed IP more than twice in little time! It may connection information had been leaked!

## Done in autogenerate layers
- Serialize and deserialize data format like json, xml, binary, ... would be faster up to 5x because of not use of reflection   
  e.g. https://github.com/mailru/easyjson , https://github.com/pquerna/ffjson
- Check & validate request data
- Make handlers to receive data and call service functions.
- Make API documentation in many standards e.g. OpenAPI(Swagger), ...
- Make SDK in multi language & system e.g. Go, TS, ...

## Implementations
- [Go](https://github.com/SabzCity/libgo/Achaemenid)

## Inspired of
- http://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html

## Achaemenid word meaning
["Achaemenid"](https://en.wikipedia.org/wiki/Satrap) (Persian: ساتراپ) were the governors of the provinces of the ancient Median and Achaemenid Empires and in several of their successors, such as in the Sasanian Empire and the Hellenistic empires
